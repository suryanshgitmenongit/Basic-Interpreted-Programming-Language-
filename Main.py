# -*- coding: utf-8 -*-
"""Onlyonefile.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PfBH21Uf5PdKjHgUMCSZlx0uEtk3rGdC
"""

class Token:
    def __init__(self, type, value):
        self.type = type
        self.value = value

    def __repr__(self):
        return f"{self.type}({self.value})"

class Integer(Token):
    def __init__(self, value):
        super().__init__("INT", value)

class Float(Token):
    def __init__(self, value):
        super().__init__("FLT", value)

class Operation(Token):
    def __init__(self, value):
        super().__init__("OP", value)

class Declaration(Token):
    def __init__(self, value):
        super().__init__("DECL", value)

class Variable(Token):
    def __init__(self, value):
        super().__init__("VAR", value)

class Boolean(Token):
    def __init__(self, value):
        super().__init__("BOOL", value)

class Comparison(Token):
    def __init__(self, value):
        super().__init__("COMP", value)

class Reserved(Token):
    def __init__(self, value):
        super().__init__("RSV", value)

class Lexer:
    digits = "0123456789"
    letters = "abcdefghijklmnopqrstuvwxyz"
    operations = "+-*/()=;"
    stopwords = [" "]
    declarations = ["let"]
    boolean = ["and", "or", "not"]
    comparisons = [">", "<", ">=", "<=", "=="]
    reserved = ["if", "elif", "else", "do", "while", "for"]

    def __init__(self, text):
        self.text = text
        self.pos = 0
        self.current_char = self.text[self.pos] if self.pos < len(self.text) else None

    def advance(self):
        self.pos += 1
        self.current_char = self.text[self.pos] if self.pos < len(self.text) else None

    def skip_whitespace(self):
        while self.current_char is not None and self.current_char.isspace():
            self.advance()

    def number(self):
        result = ''
        while self.current_char is not None and self.current_char.isdigit():
            result += self.current_char
            self.advance()

        if self.current_char == '.':
            result += self.current_char
            self.advance()
            while self.current_char is not None and self.current_char.isdigit():
                result += self.current_char
                self.advance()
            return Float(float(result))
        else:
            return Integer(int(result))

    def word(self):
        result = ''
        while self.current_char is not None and self.current_char.isalnum():
            result += self.current_char
            self.advance()

        if result in self.declarations:
            return Declaration(result)
        elif result in self.boolean:
            return Boolean(result)
        elif result in self.reserved:
            return Reserved(result)
        else:
            return Variable(result)

    def get_next_token(self):
        while self.current_char is not None:
            if self.current_char.isspace():
                self.skip_whitespace()
                continue

            if self.current_char.isdigit():
                return self.number()

            if self.current_char.isalpha():
                return self.word()

            if self.current_char in self.operations:
                op = self.current_char
                self.advance()
                return Operation(op)

            if self.current_char in '<>=':
                comp = self.current_char
                self.advance()
                if self.current_char == '=':
                    comp += self.current_char
                    self.advance()
                return Comparison(comp)

            raise Exception(f"Invalid character: {self.current_char}")

        return Token('EOF', None)

    def tokenize(self):
        tokens = []
        while (token := self.get_next_token()).type != 'EOF':
            tokens.append(token)
        return tokens

class Parser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.pos = 0
        self.current_token = self.tokens[self.pos]

    def advance(self):
        self.pos += 1
        if self.pos < len(self.tokens):
            self.current_token = self.tokens[self.pos]
        else:
            self.current_token = None

    def factor(self):
        token = self.current_token
        if token.type in ('INT', 'FLT'):
            self.advance()
            return token
        elif token.type == 'VAR':
            self.advance()
            return token
        elif token.value == '(':
            self.advance()
            result = self.expr()
            if self.current_token.value != ')':
                raise Exception("Missing closing parenthesis")
            self.advance()
            return result
        elif token.value in ('+', '-'):
            self.advance()
            return [token, self.factor()]
        raise Exception(f"Unexpected token: {token}")

    def term(self):
        result = self.factor()
        while self.current_token is not None and self.current_token.value in ('*', '/'):
            token = self.current_token
            self.advance()
            result = [result, token, self.factor()]
        return result

    def expr(self):
        result = self.term()
        while self.current_token is not None and self.current_token.value in ('+', '-'):
            token = self.current_token
            self.advance()
            result = [result, token, self.term()]
        return result

    def comparison(self):
        result = self.expr()
        if self.current_token is not None and self.current_token.type == 'COMP':
            token = self.current_token
            self.advance()
            result = [result, token, self.expr()]
        return result

    def boolean(self):
        result = self.comparison()
        while self.current_token is not None and self.current_token.type == 'BOOL':
            token = self.current_token
            self.advance()
            result = [result, token, self.comparison()]
        return result

    def statement(self):
        if self.current_token.type == 'DECL':
            self.advance()
            var = self.current_token
            self.advance()
            if self.current_token.value != '=':
                raise Exception("Expected '=' in variable declaration")
            self.advance()
            expr = self.boolean()
            return ['assign', var, expr]
        elif self.current_token.value == 'if':
            return self.if_statement()
        elif self.current_token.value == 'while':
            return self.while_statement()
        elif self.current_token.value == 'for':
            return self.for_statement()
        else:
            return self.boolean()

    def if_statement(self):
        self.advance()  # consume 'if'
        condition = self.boolean()
        if self.current_token.value != 'do':
            raise Exception("Expected 'do' after if condition")
        self.advance()  # consume 'do'
        true_stmt = self.statement()
        false_stmt = None
        if self.current_token is not None and self.current_token.value == 'else':
            self.advance()  # consume 'else'
            false_stmt = self.statement()
        return ['if', condition, true_stmt, false_stmt]

    def while_statement(self):
        self.advance()  # consume 'while'
        condition = self.boolean()
        if self.current_token.value != 'do':
            raise Exception("Expected 'do' after while condition")
        self.advance()  # consume 'do'
        body = self.statement()
        return ['while', condition, body]

    def for_statement(self):
        self.advance()  # consume 'for'
        init = self.statement()
        if self.current_token.value != ';':
            raise Exception("Expected ';' in for loop")
        self.advance()  # consume ';'
        condition = self.boolean()
        if self.current_token.value != ';':
            raise Exception("Expected ';' in for loop")
        self.advance()  # consume ';'
        update = self.statement()
        if self.current_token.value != 'do':
            raise Exception("Expected 'do' in for loop")
        self.advance()  # consume 'do'
        body = self.statement()
        return ['for', init, condition, update, body]

    def parse(self):
        return self.statement()


class Interpreter:
    def __init__(self):
        self.variables = {}

    def visit(self, node):
        if isinstance(node, list):
            if node[0] == 'assign':
                return self.visit_assign(node)
            elif node[0] == 'if':
                return self.visit_if(node)
            elif node[0] == 'while':
                return self.visit_while(node)
            elif node[0] == 'for':
                return self.visit_for(node)
            else:
                return self.visit_operation(node)
        elif isinstance(node, Token):
            if node.type in ('INT', 'FLT'):
                return float(node.value)
            elif node.type == 'VAR':
                if node.value not in self.variables:
                    raise NameError(f"Variable '{node.value}' is not defined")
                return self.variables[node.value]
        return 0

    def visit_assign(self, node):
        var_name = node[1].value
        value = self.visit(node[2])
        self.variables[var_name] = value
        return value

    def visit_if(self, node):
        condition = self.visit(node[1])
        if condition:
            return self.visit(node[2])
        elif node[3]:
            return self.visit(node[3])

    def visit_while(self, node):
        while self.visit(node[1]):
            self.visit(node[2])

    def visit_for(self, node):
        self.visit(node[1])  # init
        while self.visit(node[2]):  # condition
            self.visit(node[4])  # body
            self.visit(node[3])  # update

    def visit_operation(self, node):
        if len(node) == 2:  # unary operation
            op = node[0].value
            value = self.visit(node[1])
            if op == '-':
                return -value
            elif op == 'not':
                return not value
            return value
        else:  # binary operation
            left = self.visit(node[0])
            op = node[1].value
            right = self.visit(node[2])
            if op == '+': return left + right
            elif op == '-': return left - right
            elif op == '*': return left * right
            elif op == '/':
                if right == 0:
                    raise ZeroDivisionError("Division by zero")
                return left / right
            elif op == '>' : return left > right
            elif op == '<' : return left < right
            elif op == '>=': return left >= right
            elif op == '<=': return left <= right
            elif op == '==': return left == right
            elif op == 'and': return left and right
            elif op == 'or' : return left or right
        raise Exception(f"Unknown operator: {op}")

    def interpret(self, tree):
        return self.visit(tree)

def run_thoth():
    interpreter = Interpreter()
    print("Poverty Interpreter")
    print("Type 'exit' to quit")
    while True:
        try:
            text = input('Poverty> ')
            if text.lower() == 'exit':
                break
            if text.strip() == '':
                continue
            lexer = Lexer(text)
            tokens = lexer.tokenize()
            parser = Parser(tokens)
            tree = parser.parse()
            result = interpreter.interpret(tree)
            if result is not None:
                print(result)
        except Exception as e:
            print(f"Error: {str(e)}")

if __name__ == '__main__':
    run_thoth()

"""----------------------------------------------------------------------------------------------------------------------------------------------------"""

